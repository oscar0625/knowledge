https://segmentfault.com/a/1190000012925872

# CPU，GPU，内存和多进程架构
https://developers.google.com/web/updates/2018/09/inside-browser-part1
## 浏览器的多进程
以 Chrome 为例，它由多个进程组成，每个进程都有自己核心的职责，它们相互配合完成浏览器的整体功能，每个进程中又包含多个线程，一个进程内的多个线程也会协同工作，配合完成所在进程的职责。
```
    进程与线程的一个简单解释
    http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html
```
## 浏览器的架构
Chrome 采用多进程架构，其顶层存在一个 Browser process 用以协调浏览器的其它进程。
![](https://developers.google.com/web/updates/images/inside-browser/part1/browser-arch2.png)
```
    具体说来，Chrome 的主要进程及其职责如下：
        1.Browser Process：浏览器的主进程（负责协调、主控），只有一个。
            负责包括地址栏，书签栏，前进后退按钮等部分的工作；
            负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问；
        2.Renderer Process：浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。
            负责一个 tab 内关于网页呈现的所有事情
        3.Plugin Process：每种类型的插件对应一个进程，仅当使用该插件时才创建
            负责控制一个网页用到的所有插件，如 flash
        4.GPU Process：最多一个，用于3D绘制等
            负责处理 GPU 相关的任务
```
![](https://developers.google.com/web/updates/images/inside-browser/part1/browserui.png)
```
    Chrome 多进程架构的优缺点
        优点
            某一渲染进程出问题不会影响其他进程
            更为安全，在系统层面上限定了不同进程的权限
            简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；
        缺点
            由于不同进程间的内存不共享，不同进程的内存常常需要包含相同的内容。
            为了节省内存，Chrome 限制了最多的进程数，最大进程数量由设备的内存和 CPU 能力决定，当达到这一限制时，新打开的 Tab 会共用之前同一个站点的渲染进程。
```

# 导航中会发生什么(Browser Process)
https://developers.google.com/web/updates/2018/09/inside-browser-part2
![](https://developers.google.com/web/updates/images/inside-browser/part2/browserprocesses.png)
```
    UI thread ： 控制浏览器上的按钮及输入框；
    network thread: 处理网络请求，从网上获取数据；
    storage thread: 控制文件等的访问；
```

# 重点是浏览器内核（Renderer Process）
请牢记，浏览器的渲染进程是多线程的
## 渲染进程中主要常驻线程
```
    1. GUI渲染线程
        负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
        当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
        注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
    2. JS引擎线程
        也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
        JS引擎线程负责解析Javascript脚本，运行代码。
        JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
        同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
    3. 事件触发线程
        归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
        当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
        当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
        注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
    4. 定时触发器线程
        传说中的setInterval与setTimeout所在线程
        浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
        因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
        注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
    5. 异步http请求线程
        在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
        将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。
        由于浏览器发出网络请求需要新开线程，所以可以发出请求的端口数量有限，从开销角度考虑不可能无限发出并发请求；
```
## 梳理浏览器内核中线程之间的关系
```
    1. GUI渲染线程与JS引擎线程互斥(JS引擎线程优先级高)
        为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，
        GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。
    2. JS阻塞页面加载
        从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。
        所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。
    3. WebWorker，JS的多线程?
        创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）
        JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）
        注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。
```
## 渲染的流程
```
    1. 解析html 建立dom树
    2. 样式计算 构建render树
    将CSS代码解析成树形的数据结构，然后结合DOM合并成render树。(即使不提供任何 CSS，浏览器对每个元素也会有一个默认的样式。)
    3. 布局 render树（Layout/reflow）
    布局其实是找到所有元素的几何关系的过程。布局树和 DOM 树类似，但是其中只包含页面可见的元素，如果一个元素设置了 display:none ，这个元素不会出现在布局树上，伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。
    4. 绘制 render树（paint）
    拥有DOM，样式和布局仍然不足以呈现页面。假设您正在尝试复制一幅画。您知道元素的大小，形状和位置，但是仍然需要判断以什么顺序绘制它们。
    5. 合成
    浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。
```
## 子资源加载
css加载
```
    首先，我们都知道：css是由单独的下载线程异步下载的。(在 html 中存在 <img> <link> 等标签，会把这些请求传递给 Browser process 中的 network thread 进行相关资源的下载。)
    然后再说下几个现象：
        css加载不会阻塞DOM树解析（异步加载时DOM照常构建）
        但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）
```
JS的加载
```
     当遇到 <script> 标签时，渲染进程会停止解析 HTML，而去加载，解析和执行 JS 代码，停止解析 html 的原因在于 JS 可能会改变 DOM 的结构（使用诸如 documwnt.write()等 API）。
```
加载优化
```
    开发者其实也有多种方式来告知浏览器应对如何应对某个资源，比如说如果在<script> 标签上添加了 async 或 defer 等属性，浏览器会异步的加载和执行 JS 代码，而不会阻塞渲染。<link rel="preload">是一种通知浏览器该资源绝对是当前导航所必需的一种方式，您希望尽快下载。
```
## 合成
```
    渲染步骤中就提到了composite概念，可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层以及复合图层。
    首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）。其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）。可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒
```
如何变成复合图层（硬件加速）
```
    将该元素变成一个复合图层，就是传说中的硬件加速技术
        1. 最常用的方式：translate3d、translateZ
        2. opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
        3. will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）
        4. <video><iframe><canvas><webgl>等元素
```
复合图层的作用？
```
    一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能
    但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡
```

# 输入即将进入合成器
https://developers.google.com/web/updates/2018/09/inside-browser-part4
```
    从浏览器的角度来看，输入表示用户的任何手势。鼠标滚轮滚动是一个输入事件，触摸或鼠标悬停也是一个输入事件。
    当用户在屏幕上触发诸如 touch 等手势时，首先收到手势信息的是 Browser process， 不过 Browser process 只会感知到在哪里发生了手势，对 tab 内内容的处理是还是由渲染进程控制的。事件发生时，浏览器进程会发送事件类型及相应的坐标给渲染进程，渲染进程随后找到事件对象并执行所有绑定在其上的相关事件处理函数。
```
建议添加{passive: true}事件处理程序