<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="renderer" content="webkit" />
    <title>HTTPS原理</title>
</head>

<body>


</body>
<script>
    //  一、HTTPS
    //      HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。
    //  HTTP与HTTPS的区别
    //      1.HTTP是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。
    //      2.HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;
    //      3.HTTPS需要用到SSL证书，而HTTP不用;
    //      4.HTTPS标准端口443，HTTP标准端口80;
    //      5.HTTPS基于传输层，HTTP基于应用层;
    //      6.HTTPS在浏览器显示绿色安全锁，HTTP没有显示;

    //  二、HTTP协议存在的哪些问题
    //      1.通信使用明文（不加密），内容可能被窃听
    //      2.无法证明报文的完整性，所以可能遭篡改
    //      3.不验证通信方的身份，因此有可能遭遇伪装

    //  三、HTTPS如何解决HTTP上述问题?
    //      1.解决内容可能被窃听的问题——加密（非对称加密+对称加密）
    //      2.解决报文可能遭篡改问题——数字签名
    //      3.解决通信方身份可能被伪装的问题——数字证书
    //  工作原理：
    //      所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。
    //      HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数、对称加密和非对称加密
    //      利用非对称加密实现身份认证和密钥协商
    //      对称加密采用协商的密钥对数据进行加密解密
    //      基于散列函数验证信息的完整性

    //  四、其他
    //  1.加密
    //      非对称加密
    //          使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。这个密码体制分为三部分，公钥、私钥、加密算法，其中公钥和加密算法是公布的，私钥是自己保密的。这种机制最大的特点是，通过公钥加密的密文只有对应的私钥才能解密，同样通过私钥加密的密文也只有对应的公钥才能解密。
    //      对称加密
    //          加密使用的秘钥和解密使用的秘钥是相同的，也就是说加密和解密都使用同一个秘钥，加密算法是公开的，秘钥是加密者和解密者绝对保密的。
    //      非对称加密+对称加密
    //          在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。
    //          具体做法是：发送密文的一方使用对方的公钥进行加密处理“对称密钥”，然后对方用自己的私钥解密拿到“对称密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制。

    //  2.数字证书
    //      是由权威的证书颁发机构（Certificate Authority，简称CA）颁发的，有点像身份证，证书的主要内容有：公钥（Public Key）、ISSUER（证书的发布机构）、Subject（证书持有者）、证书有效期、签名算法、签名（指纹）。
    //      办理数字证书的业务流程：
    //          服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;
    //          CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;
    //          如信息审核通过，CA会向申请者签发认证文件-证书。

    //  3.数字签名
    //      签名是用来验证证书内容有没有被篡改的。
    //      签名算法：散列函数
    //      签名的产生：首先，使用签名算法计算公开的明文内容得到一个hash值，然后，采用CA机构自己的根私钥对前一个hash值进行加密得到一个hash值，这个hash值只有对应的根公钥才能解密。
    //      签名的验证：客户端Client读取证书中的明文内容，采用相同的签名算法计算得到hash值h1，然后，利用对应CA的公钥解密签名得到hash值h2，对比h1和h2，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。

    //  五、工作流程：
    //      1.首先浏览器通过URL网址去请求某个后台服务器，后台接收到请求后，就会给浏览器发送一个自己的CA数字证书。
    //      2.浏览器接收到数字证书以后，就要开始进行验证工作了。首先从证书的内容中获取证书的颁发机构，然后从浏览器系统中去寻找此颁发机构是否为浏览器的信任机构。（这里解析一下，世界上就几个权威的CA机构，这几个机构的信息都是预先嵌入到我们的浏览器系统中的。如果收到的一个数字证书但其颁发机构没有在我们浏览器系统中的，那么就会有警告提示无法确认证书的真假 如果是受信任的机构，那么就到下一步）
    //      此时我们就可以从浏览器中找到CA机构的根公钥，用这个公钥去解析证书的签名得到一个hash值H1，然后用证书的签名算法对证书的明文内容再进行计算得到另一个hash值H2，如果此时H1和H2是相等的，就代表证书没有被修改过。在证书没有被修改过的基础上。
    //      再检查证书上的使用者的URL和我们请求的URL是否相等，如果相等，那么就可以证明当前浏览器连接的网址也是正确的，而不是一些钓鱼网之类的。
    //      3.下一步有一个很重要的任务就是，如何将一个对称加密算法的秘钥安全地发给服务器。
    //      首先随机生成一个字符串S作为我们的秘钥，然后通过证书公钥加密，将密文发送给服务器。因为此密文是用公钥加密的，这是一个非对称加密，我们知道，这个密文只有私钥的持有者才能进行解密，所以说任何第三方截取到密文也是没用的，因为没有对应的私钥所以解析不出来。
    //      一个关键步骤，发送密文的时候也会对消息内容进行签名操作。签名上面讲解过，就是用签名算法对明文内容进行计算得到的一个hash值，将这个hash值再加密以后和消息内容一起发送出去。接收方收到消息以后，通过私钥解析出签名和密文，同时也会对接收的明文内容进行签名算法的计算得到另一个hash值，通过比对两个hash值是否相同来判断密文是否有修改过。
    //      通过了上面的步骤以后， 此时客户端和服务端都持有了对称加密算法的秘钥， 然后兄弟两就可以愉快地安全通信了。
    //      4.总结：数字证书的验证有两个重要的步骤，第一是验证数字证书没有被篡改以及连接的URL是否正确，第二是通过RSA机制的原理安全地将对称加密算法的秘钥发送给对方。 
</script>

</html>