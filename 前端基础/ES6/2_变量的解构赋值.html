<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="renderer" content="webkit" />
    <title>变量的解构赋值</title>
</head>

<body>
</body>
<script>
    // 变量的解构赋值：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构
    // 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。
    //  注意：解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。
    //      let {}=[1,2,3]

    // 数组的解构赋值(以下几条对象也是)
    //  1.等号左边多右边少，有变量解构失败，则变量的值等于undefined 
    //  2.等号左边少右边多，有部分变量解构成功，即不完全结构（允许），只匹配一部分等号右边的项
    //  3.可以指定默认值 (默认值生效的条件是，那一项严格等于undefined)。
    //     let [x, y = 'b'] = ['a']; // x='a', y='b';
    //     let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'

    // 对象的解构赋值
    //  1.对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
    //  2.let { foo, bar } = { foo: "aaa", bar: "bbb" } 实际上是 let { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" } (因为对象属性的简洁表示法)
    //    对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的(是变量的)是后者，而不是前者,前者是模式。
    //    e:如果变量名与属性名不一致，必须写成下面这样
    //         let {first:f,last:l}={ first: 'hello', last: 'world' }
    //         f//hello l//world
    //         first//error  last//error 因为first和last并不是变量

    //  注意：如果要将一个已经声明的变量用于解构赋值，必须非常小心。不将大括号写在行首，避免JavaScript将其解释为代码块
    //    e:
    //      let x; {x} = {x: 1};//出错
    //      解决：let x; ({x} = {x: 1})


    //  用途 
    //  1.交换变量的值
    //  2.函数参数的定义
    //  3.从函数返回多个值
    //  4.输入模块的指定方法
    //  5.遍历 Map 结构
    const m = new Map([
        ['name', '张三'],
        ['title', 'Author']
    ]);
    for (let [key, value] of m) {
        console.log(key + " is " + value);
    }
</script>

</html>