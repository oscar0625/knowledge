# 1. 减少 HTTP 请求
一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。
建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。
```
    接下来看一个具体的例子帮助理解 HTTP ：
        Queueing: 在请求队列中的时间。
        Stalled: 从 TCP 连接建立完成，到真正可以传输数据之间的时间差，此时间包括代理协商时间。
        Proxy negotiation: 与代理服务器连接进行协商所花费的时间。
        DNS Lookup: 执行 DNS 查找所花费的时间，页面上的每个不同的域都需要进行 DNS 查找。
        Initial Connection / Connecting: 建立连接所花费的时间，包括 TCP 握手/重试和协商 SSL。
        SSL: 完成 SSL 握手所花费的时间。
        Request sent: 发出网络请求所花费的时间，通常为一毫秒的时间。
        Waiting(TFFB): TFFB 是发出页面请求到接收到应答数据第一个字节的时间总和，它包含了 DNS 解析时间、 TCP 连接时间、发送 HTTP 请求时间和获得响应消息第一个字节的时间。
        Content Download: 接收响应数据所花费的时间。
```

# 2. 使用 HTTP2 待续

# 3. 使用服务端渲染
```
    客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。
    服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。
        优点：首屏渲染快，SEO 好。
        缺点：配置麻烦，增加了服务器的计算压力。
```

# 4. 静态资源使用 CDN
内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。
```
    当用户访问一个网站时，如果没有 CDN，过程是这样的：
        浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。
        本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址。
        本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源。
    如果用户访问的网站部署了 CDN，过程是这样的：
        浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。
        本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。
        本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。
        本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。
        SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。
        浏览器再根据 SLB 发回的地址重定向到缓存服务器。
        如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。
```

# 5. 将 CSS 放在文件头部，JavaScript 文件放在底部

# 6. 使用字体图标 iconfont 代替图片图标

# 7. 善用缓存，不重复加载相同的资源 待续

# 8. 压缩文件 待续
```
    在 webpack 可以使用如下插件进行压缩：
        JavaScript：UglifyPlugin
        CSS ：MiniCssExtractPlugin
        HTML：HtmlWebpackPlugin
    附上 webpack 和 node 配置 gzip 的使用方法。  
        npm install compression-webpack-plugin --save-dev
        npm install compression  
```

# 9. 图片优化
```
    (1)图片延迟加载
    (2)响应式图片:响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。
        通过 picture 实现
        通过 @media 实现
    (3)调整图片大小    
        我们可以用两张图片来实行优化。一开始，只加载缩略图，当用户悬停在图片上时，才加载大图。
    (4)降低图片质量
        压缩方法有两种，一是通过 webpack 插件 image-webpack-loader，二是通过在线网站进行压缩。
    (5)尽可能利用 CSS3 效果代替图片    
```

# 10.通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码
```
    (1)根据文件内容生成文件名，结合 import 动态引入组件实现按需加载
        通过配置 output 的 filename 属性可以实现这个需求。
    (2)提取第三方库    
        这里需要使用 webpack4 的 splitChunk 插件 cacheGroups 选项。
    (3)减少 ES6 转为 ES5 的冗余代码    
```

# 11.减少重绘重排
```
    什么操作会导致重排？
        添加或删除可见的 DOM 元素
        元素位置改变
        元素尺寸改变
        内容改变
        浏览器窗口尺寸改变
    如何减少重排重绘？    
        用 JavaScript 修改样式时，最好不要直接写样式，而是替换 class 来改变样式。
        如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（display:none）或文档碎片（DocumentFragement），都能很好的实现这个方案。
```

# 12.使用事件委托

# 14. if-else 对比 switch
当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。

# 15.查找表
当条件语句特别多时，使用 switch 和 if-else 不是最佳的选择，这时不妨试一下查找表。
```
    const map = {
        red: result0,
        green: result1,
    }
    return map[color]
```

# 16.避免页面卡顿
```
    目前大多数设备的屏幕刷新率为 60 次/秒(60fps)。其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。此现象通常称为卡顿，会对用户体验产生负面影响。
    假如你用 JavaScript 修改了 DOM，并触发样式修改，经历重排重绘最后画到屏幕上。如果这其中任意一项的执行时间过长，都会导致渲染这一帧的时间过长，平均帧率就会下降。假设这一帧花了 50 ms，那么此时的帧率为 1s / 50ms = 20fps，页面看起来就像卡顿了一样。
```

# 17.使用 requestAnimationFrame 来实现视觉变化
而保证 JavaScript 在帧开始时运行的唯一方式是使用 requestAnimationFrame。


# 18.使用 Web Workers

# 19.使用位操作 待续
JavaScript 中的数字都使用 IEEE-754 标准以 64 位格式存储。但是在位操作中，数字被转换为有符号的 32 位格式。即使需要转换，位操作也比其他数学运算和布尔操作快得多。

# 20.不要覆盖原生方法
无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，成为浏览器的一部分。当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。

# 21.降低 CSS 选择器的复杂性

# 22.使用 flexbox 而不是较早的布局模型
新的布局方式 flexbox[28]，它比起早期的布局方式来说有个优势，那就是性能比较好。

# 23.使用 transform 和 opacity 属性更改来实现动画
在 CSS 中，transforms 和 opacity 这两个属性更改不会触发重排与重绘，它们是可以由合成器（composite）单独处理的属性。

# 24.合理使用规则，避免过度优化
```
    (1)性能优化主要分为两类：
        加载时优化
        运行时优化
    上述 23 条建议中，属于加载时优化的是前面 10 条建议，属于运行时优化的是后面 13 条建议。

    (2)检查加载性能
    一个网站加载性能如何主要看白屏时间和首屏时间。
        白屏时间：指从输入网址，到页面开始显示内容的时间。
            new Date() - performance.timing.navigationStart
        首屏时间：指从输入网址，到页面完全渲染的时间。
        首屏时间比较复杂，得考虑有图片和没有图片的情况。
            如果没有图片，则在 window.onload 事件里执行 new Date() - performance.timing.navigationStart 即可获取首屏时间
            如果有图片，则要在最后一个在首屏渲染的图片的 onload 事件里执行 new Date() - performance.timing.navigationStart 获取首屏时间
    (3)检查运行性能
    chrome 的开发者工具performance
```